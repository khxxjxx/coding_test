## 시차의 폭풍은 정말 최고야!

### 문제 설명

- 체스판에서 말이 한번 움직일때마다 한칸앞으로 간 후 대각선 방향으로 이동한다고 할 때, 출발지점에서 도착지점까지 몇번을 움직이는지 구하는 문제.<br>

### 자료 구조

- q<br>

  - 타입 : 정수 배열
  - 저장 데이터 : 이동횟수, 현재좌표

- chess<br>

  - 타입 : 정수 이중배열
  - 저장 데이터 : 방문하지않은 곳은 1, 방문한곳은 0

- next<br>
  - 타입 : 정수 배열
  - 저장 데이터 : 현재좌표에서 이동할 수 있는 다음좌표

### 풀이 과정

```txt
1. 입력받은 체스판 크기에 맞춰 1로 초기화한 이차원 배열을 만들어준다.

2. 말이 한번 움직일 때 도착 가능한 지점은 최대 8군데이고 이동가능한 좌표를 배열에 저장해둔다.

3. 큐에 이동 횟수 0과 출발지점을 넣어주고 출발지점 좌표를 0으로 바꿔준다.

4. while문을 q에 더이상 값이 없을때까지 돌아주며 만약 도착지점에 도착하면 현재 이동횟수를 출력하고 루프를 종료한다.

5. 현재좌표에서 말이 갈수있는 방향을 더해서 새로운 변수에 넣어주고 그 값이 0이상이고 체스판크기보다 작다면 큐에 이동횟수에 1을 더한값과 변수를 넣어준 후, 그 좌표를 0으로 바꿔준다.
```

### 코드 구현

사용 언어 : 파이썬

```py
from collections import deque

n = int(input())
# 풀이 과정 1
chess = [[1]*n for _ in range(n)]

start = list(map(int, input().split()))
end = list(map(int, input().split()))

# 풀이 과정 2
xy = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]

# 풀이 과정 3
q = deque([[0, start]])
chess[start[0]][start[1]] = 0

while q:
    time, now = q.popleft()

    # 풀이 과정 4
    if now == end:
        print(time)
        break

    for i in range(8):
        # 풀이 과정 5
        next = [now[0]+xy[i][0], now[1]+xy[i][1]]

        if 0 <= next[0] < n and 0 <= next[1] < n and chess[next[0]][next[1]]:
            chess[next[0]][next[1]] = 0
            q.append([time+1, next])
```

input

```
5
0 0
0 4
```

output

```
2
```

점수 : 100 / 100<br>
