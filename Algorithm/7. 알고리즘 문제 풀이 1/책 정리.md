## 책 정리

### 문제 설명

- 뒤죽박죽되어있는 숫자들을 하나씩 옮겨서 오름차순으로 정렬 할 때, 최소 횟수를 구하는 문제.<br>

### 자료 구조

- LIS<br>

  - 타입 : 정수 배열
  - 저장 데이터 : 가장 긴 증가하는 부분 수열

### 풀이 과정

```txt
1. 연속되어있는 수들 중에 제일 길게 연결되어 있는 수들을 찾기 위해 LIS배열을 만들고 그 안에 처음 입력된 수를 넣어준다.

2. LIS배열의 마지막 수 보다 입력된 값이 더 크다면 LIS에 넣어준다.

3. LIS배열의 마지막 수보다 입력된 값이 더 작다면 bisect_left모듈을 이용해 오름차순 정렬된 LIS배열에서 현재값이 들어갈 위치를 구한 후 해당 위치의 값을 현재값으로 바꿔준다.(이 문제에선 LIS값을 구하는게 아닌 길이만 구하면 되기때문에 그냥 바꿔주기만 해도 된다.)

4. LIS가 아닌 수들은 옮겨줘야하므로 정렬해야하는 수의 총 개수에서 LIS에 해당되는 수들의 개수를 뺴준다.
```

### 코드 구현

사용 언어 : 파이썬

```py
from bisect import bisect_left

N = int(input())
arr = list(map(int, input().split()))

# 풀이 과정 1
LIS = [arr[0]]

for i in arr[1:]:
    # 풀이 과정 2
    if LIS[-1] < i:
        LIS.append(i)
    # 풀이 과정 3
    else :
        LIS[bisect_left(LIS, i)] = i

# 풀이 과정 4
print(N - len(LIS))
```

input

```
5
2 1 4 5 3
```

output

```
2
```

점수 : 100 / 100<br>
